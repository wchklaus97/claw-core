# CPU 與記憶體控制 — 保持服務層存活

用於限制 CPU 與記憶體佔用，確保失控會話或命令**不會**拖垮整個 Runtime。

## 目標

- **子程序**（會話中執行的命令）不能耗盡主機 CPU 或記憶體
- **Runtime 程序**（Rust 守護程序）必須保持在可控邊界內
- **失敗策略**：命中限制時，只拒絕或終止問題單元（某個會話/某條命令），而不是整服務崩潰

## 1. 應用層控制（全平台）

### 1.1 會話與並行限制

| 控制項 | 目的 | 範例 |
|--------|---------|---------|
| **最大會話數** | 限制會話總量 | `max_sessions: 64` |
| **最大並行命令數** | 限制同一時刻命令量 | 每會話 1 條或全域 16 條 |
| **會話空閒超時** | 銷毀長期空閒會話 | `max_idle_sec: 3600` |
| **每客戶端最大會話數** | 可選限制 | 例如每客戶端 8 個 |

### 1.2 單命令限制

| 控制項 | 目的 | 範例 |
|--------|---------|---------|
| **命令超時** | 停止長時間命令 | 每次 `exec.run` 傳 `timeout_s: 300` |
| **預設超時** | 兜底超時 | 例如 60 秒 |
| **輸出緩衝上限** | 限制 stdout/stderr 體積 | 例如每路 4 MiB |
| **stdin 大小上限** | 限制輸入大小 | 例如 1 MiB |

### 1.3 背壓與拒絕

- 當 `active_sessions >= max_sessions` 時，**拒絕新會話**
- 當會話忙碌時，**拒絕新命令**（回傳 `SESSION_BUSY`）
- **可選**：對每客戶端 API 請求做速率限制

### 1.4 Runtime 自監控

- **週期回收**：殭屍子程序、死亡會話
- **健康端點**：`system.ping` / `system.stats`
- **優雅停機**：收到 SIGTERM 後停止接新請求，排空或終止命令，再銷毀會話

## 2. 子程序資源限制（Unix）

在子程序執行前使用 **setrlimit**。Rust 中可用 `Command::unsafe_pre_exec`。

| 資源 | 常數 | 效果 |
|----------|----------|--------|
| **CPU 時間（秒）** | `RLIMIT_CPU` | CPU 時間超限後程序會被殺死 |
| **虛擬位址空間（位元組）** | `RLIMIT_AS` | 限制虛擬記憶體 |
| **程序數** | `RLIMIT_NPROC` | 防止命令 fork 炸彈 |
| **開啟檔案數** | `RLIMIT_NOFILE` | 防止檔案描述符耗盡 |

**Rust crate：** `rlimit`（docs.rs/rlimit），僅 Unix。

**設定建議：** 參數化限制（如 `limit_cpu_sec`、`limit_memory_bytes`、`limit_nproc`）。

## 3. Cgroups（Linux）— 更強隔離

若需要**嚴格**的會話級 CPU 與記憶體限制，使用 cgroups 由核心強制執行。

| 目標 | 機制 |
|------|------------|
| **會話級記憶體上限** | cgroup v2 `memory.max` |
| **會話級 CPU 上限** | cgroup v2 `cpu.max`（quota + period） |
| **作用範圍** | 每個會話一個 cgroup；shell 及其子程序都加入該組 |

**Rust crate：** `cgroups-rs`（kata-containers/cgroups-rs）。

## 4. 實施順序總結

| 層 | MVP（先上線） | 下一步（L2） |
|-------|------------------|-----------|
| **應用層** | 最大會話數、命令超時、輸出緩衝上限、容量拒絕、優雅停機 | 會話空閒超時、每客戶端限制、速率限制 |
| **子程序層** | 在 `pre_exec` 設定 `RLIMIT_CPU`、`RLIMIT_AS`、`RLIMIT_NPROC`（可設定） | 按環境微調參數 |
| **Linux 隔離層** | — | 每會話 cgroups（`memory.max`、`cpu.max`） |
| **記憶體層** | 限制索引大小或批次大小 | 查詢限速與監控 |

**原則：** 先做**應用層 + setrlimit**（macOS/Linux 都可用、無需 root），需要更強隔離再上 Linux **cgroups**。

## 5. 防止服務層崩潰檢查清單

- [x] 已設定 **max_sessions**，超限時拒絕
- [x] 已強制 **命令超時**（預設值 + 每請求覆蓋）
- [x] 已限制 **輸出緩衝**（stdout/stderr）
- [x] 每個子程序在 **pre_exec** 設定 **RLIMIT_CPU**、**RLIMIT_AS**（可選 NPROC）
- [x] 支援 SIGTERM 下的 **優雅停機**
- [x] 有殭屍與死亡會話的 **週期回收**
- [ ] （L2）Linux 每會話啟用 **cgroups** 做硬性 CPU/記憶體限制
